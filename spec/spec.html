<html>
<head>
<link rel="stylesheet" href="http://yandex.st/highlightjs/7.3/styles/monokai.min.css">
<script src="http://yandex.st/highlightjs/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<style>
h1{
    padding: 5px 0 0 3%;
    border-top-width: 1px;
    border-top-style: solid;
}

pre {
    display: inline-block;
    min-width: 660px;
}

code {
    border-radius: 6px;
}

dt, dd{
    padding-left: 6%;
}
</style>
</head>
<body>
    <section class="suite">
      <h1>chainlang.create(lang)</h1>
      <dl>
        <dt>requires exactly one argument (representing the new chain language)</dt>
        <dd><pre><code>expect(callCreateWithNoArgs).to.throwException();
expect(callCreateWithTwoArgs).to.throwException();</code></pre></dd>
        <dt>returns a chain function for the new language, used to start chained expressions</dt>
        <dd><pre><code>var newLang = chainlang.create({});
expect(newLang).to.be.a('function');</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>chainlang.append(obj, path, node)</h1>
      <dl>
        <dt>Adds descendant nodes and all required ancestors to an object (like mkdirp)</dt>
        <dd><pre><code>var manualCreation = {};
manualCreation.has = {};
manualCreation.has.a = {};
manualCreation.has.a.greatGrandchild = 1;

var convenientCreation = {};
chainlang.append(convenientCreation, 'has.a.greatGrandchild', 1);

expect(manualCreation).to.eql(convenientCreation);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>A chain function returned from chainlang.create</h1>
      <dl>
        <dt>Accepts an optional argument, and throws if more than one argument is provided</dt>
        <dd><pre><code>var chain = chainlang.create({});

expect(
    function(){chain();}
).not.to.throwException();
expect(
    function(){chain({});}
).not.to.throwException();
expect(
    function(){chain({}, {});}
).to.throwException();</code></pre></dd>
        <dt>Starts a chain of methods bound to a chain object with proxied version of all the language spec fields</dt>
        <dd><pre><code>var stubLang = {
    topLevelFn: function(){},
    topLevelProp: &quot;someValue&quot;,
    secondLevel: {
        fn: function(){},
        prop: &quot;someValue&quot;,
        thirdLevel: {
            fn: function(){},
            prop: &quot;someValue&quot;
        }
    }
}

var chainConstructor = chainlang.create(stubLang);

expect(allFieldsOfFirstAppearInSecond(stubLang, chainConstructor())).to.be(true);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>A chain object</h1>
      <dl>
        <dt>Implicitly returns itself from all decendant methods</dt>
        <dd><pre><code>var chain = chainlang.create({
    returnsNothing: function(){
        return;
    },
    levelTwo: {
        returnsNothing: function(){
            return;
        }
    }
});

expect(
    chain().returnsNothing()
).to.eql(
    chain()
);

expect(
    chain().levelTwo.returnsNothing()
).to.eql(
    chain()
);</code></pre></dd>
        <dt>Will return any explicit return value instead of returning itself implicitly</dt>
        <dd><pre><code>var chain = chainlang.create({
    returnsSomething: function(){
        return 'something';
    }
});

expect(
    chain().returnsSomething()
).to.eql(&quot;something&quot;)</code></pre></dd>
        <dt>contains a &quot;_data&quot; property which can be used to pass data through the chain and is initially empty</dt>
        <dd><pre><code>var link = chainlang.create({})();
expect(link).to.have.key('_data');

var hasOwnKey = false;
for(var key in link._data){
    if(link._data.hasOwnProperty(key)){
        hasOwnKey = true;
    }
}
expect(hasOwnKey).to.be(false);</code></pre></dd>
        <dt>contains a &quot;_subject&quot; property, which references the optional parameter to the chain function</dt>
        <dd><pre><code>var chain = chainlang.create({
    getSubject: function(){
        return this._subject;
    }
});

var actualSubject = {iAm: &quot;theSubject&quot;};

expect(
    chain(actualSubject).getSubject()
).to.be.eql(actualSubject);</code></pre></dd>
        <dt>allows chaining of methods arbitrarily nested within properties of the language</dt>
        <dd><pre><code>var chain = chainlang.create(
    {
        addOne : function(){
            this._subject = this._subject + 1;
        },
        secondLevel : {
            addOne : function (){
                this._subject = this._subject + 1;
            },
            thirdLevel : {
                addOne : function(){
                    this._subject = this._subject + 1;
                }
            }                    
        }
    });

expect(
    chain(1).addOne()._subject
).to.be(2);

expect(
    chain(1).addOne().secondLevel.addOne()._subject
).to.be(3);

expect(
    chain(1).addOne().secondLevel.thirdLevel.addOne()._subject
).to.be(3);

expect(
    chain(1).addOne().secondLevel.addOne().secondLevel.thirdLevel.addOne()._subject
).to.be(4);</code></pre></dd>
        <dt>is bound to &quot;this&quot; for every method call in the chain, even for methods of child objects</dt>
        <dd><pre><code>var spy = sinon.spy();

var chain = chainlang.create({
    topLevelFn: spy,
    secondLevel: {
        secondLevelFn: spy
    }
});

var theChain = chain();

// Running some methods to spy on their `this` value
chain().topLevelFn().secondLevel.secondLevelFn();

expect(spy.thisValues[0]).to.be.eql(theChain);
expect(spy.thisValues[1]).to.be.eql(theChain);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>The _data property of a chain</h1>
      <dl>
        <dt>is initally an empty object</dt>
        <dd><pre><code>var chain = chainlang.create({});
expect(chain()._data).to.be.eql({});</code></pre></dd>
        <dt>persists for the life of the chain, and so can be used to share data between non-adjacent links in the chain</dt>
        <dd><pre><code>var chain = chainlang.create({
    setsData : function(){
        this._data.field = 1;
    },
    doesNothing : function(){
        return;
    },
    readsAndReturnsData: function(){
        return this._data.field;
    }
});

expect(
    chain().setsData().doesNothing().readsAndReturnsData()
).to.be(1);</code></pre></dd>
      </dl>
    </section>
    <section class="suite">
      <h1>Any node in the chain object graph</h1>
      <dl>
        <dt>may include child nodes, even if it is a method</dt>
        <dd><pre><code>var spy = sinon.spy();

var chainSpec = {};
chainSpec.prop = spy; /* spy is a function, so prop is a method */
chainSpec.prop.methodsStillAvailable = function(){
    return true;
}

var chain = chainlang.create(chainSpec);

chain().prop();

expect(spy.called).to.be(true);
expect(chain().prop.methodsStillAvailable()).to.be(true);</code></pre></dd>
      </dl>
    </section>

</body>