<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Chainlang : Utility for easily creating chainable methods and complex fluent APIs in JavaScript" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Chainlang</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/jbreeden/chainlang">View on GitHub</a>

          <h1 id="project_title">Chainlang</h1>
          <h2 id="project_tagline">Utility for easily creating chainable methods and complex fluent APIs in JavaScript</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/jbreeden/chainlang/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/jbreeden/chainlang/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="chainlang" class="anchor" href="#chainlang"><span class="octicon octicon-link"></span></a>Chainlang</h1>

<p>Chainlang is a utility for easily creating chainable methods and complex fluent APIs in JavaScript.</p>

<h1>
<a name="motivation" class="anchor" href="#motivation"><span class="octicon octicon-link"></span></a>Motivation</h1>

<p>Fuent APIs make code easier to read and understand. Replacing a large options object parameter with a convenient
fluent API can greatly simplify the use of many library functions. In an interactive environment like the
nodejs repl, or the Firebug console, programmers can take advantage of auto-completion and exploratory programming
to uncover the features of your fluent API without having to resort to the documentation.</p>

<h1>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Usage</h1>

<h2>
<a name="creating-a-chainable-api" class="anchor" href="#creating-a-chainable-api"><span class="octicon octicon-link"></span></a>Creating a Chainable API</h2>

<p>Just pass any JavaScript object to <code>chainlang.create</code> to create a chainable api:</p>

<pre><code>var adder = {
    add: function(val){ 
        this._subject += val; 
    },
    calc: function() { 
        return this._subject; 
    }
}

var to = chainlang.create(adder);

// Logs: 10
console.log(
    to(1).add(2).add(3).add(4).calc()
);
</code></pre>

<p><code>chainlang.create</code> will return a function that starts your chain expression. The optional parameter
to this function will be saved in <code>this._subject</code> and accessible by all of your methods. If no value
is returned by a method in the chain, the chain object itself is implicitly returned so you may
continue to chain other methods.</p>

<h2>
<a name="everything-is-chainable" class="anchor" href="#everything-is-chainable"><span class="octicon octicon-link"></span></a>Everything is Chainable</h2>

<p>The object you pass to <code>chainlang.create</code> need not have all of it's method at the root level, as in
the example above. Any method on the object graph, no matter how deeply nested, will be chainable.</p>

<pre><code>var even = {
    deeply: {
        nested: {
            methods: function(){
                return;   
            }
        }
    },
    are: {
        chainable: function(){
            console.log(true);   
        }
    }
};

var even = chainlang.create(even);

// Logs: true
even().deeply.nested.methods().are.chainable();
</code></pre>

<h2>
<a name="using-chainlangappend" class="anchor" href="#using-chainlangappend"><span class="octicon octicon-link"></span></a>Using <code>chainlang.append</code>
</h2>

<p><code>chainlang.append</code> is a simple function to help you build your language spec before passing it to
<code>chainlang.create</code>. With <code>chainlang.append</code>, you can declare leaf nodes of an object graph and
have the parent nodes filled in for you. So, the previous example could have been written like this:</p>

<pre><code>var even = {};
chainlang.append(even, 'deeply.nested.methods', function(){ return; });
chainlang.append(even, 'are.chainable', function(){ console.log(true); });
even = chainlang.create(even);

// Logs: true
even().deeply.nested.methods().are.chainable();
</code></pre>

<p>If you bind <code>chainlang.append</code> to some object, the first parameter may be omitted</p>

<pre><code>var even = {};
var define = chainlang.append.bind(even);

define('deeply.nested.methods', function(){ return; });
define('are.chainable', function(){ console.log(true); });

even = chainlang.create(even);

// Logs: true
even().deeply.nested.methods().are.chainable();
</code></pre>

<h2>
<a name="sharing-data-between-links" class="anchor" href="#sharing-data-between-links"><span class="octicon octicon-link"></span></a>Sharing Data Between Links</h2>

<p>Along with <code>this._subject</code>, all method calls have access to <code>this._data</code>. <code>this._data</code> is initially
empty, and is simply provided as a convenient place to store information between links in a chained
expression.</p>

<pre><code>var spec = {};
var define = chainlang.append.bind(spec);

define('setData', function(val){ 
    this._data.field = val; 
});
define('logData', function(){ 
    console.log(this._data.field); 
});

var chain = chainlang.create(spec);

// Logs: 999
chain().setData(999).logData();
</code></pre>

<h2>
<a name="keeping-your-privates-hidden" class="anchor" href="#keeping-your-privates-hidden"><span class="octicon octicon-link"></span></a>Keeping Your Privates Hidden</h2>

<p>Sometimes it's desirable to hide some methods of your chainable api until it makes sense to use them.
<code>chainlang</code> provides no built-in support for this, but it is recommended that you simply hide these nodes
behind a field with a name like '_private'. That way, programmers using your api will not be tempted to use
these methods in a context where it does not make sense to do so. Also, keeping them <em>all</em> behind
a field like this, instand of simply prefixing them all with an '_' will prevent the auto-completion
results from being cluttered with fields that are supposed to be private in the first place. For example:</p>

<pre><code>var delaySpec = {};
var define = chainlang.append.bind(delaySpec);

define('for', function(count){
    this._data.count = count;

    // exposing our private 'units' object now that we have a count
    return this._private.units;
});

define('_private.units.seconds.then', function(callback){
    setTimeout(callback, this._data.count * 1000);
});

define('_private.units.minutes.then', function(callback){
    setTimeout(callback, this._data.count * 1000 * 60)
});

var delay = chainlang.create(delaySpec);

// After 5 seconds, logs: '5 seconds elapsed'
delay().for(5).seconds.then(function(){
    console.log('5 seconds elapsed');
});

// After 5 minutes, logs: '5 minutes elapsed'
delay().for(5).minutes.then(function(){
    console.log('5 minutes elapsed');
});
</code></pre>

<p>In the previous example, it would not make sense to have an expression such as <code>delay().minutes.then(...)</code>.
The count needs to be declared before the units, so the units object is kept in private storage and exposed
by <code>return</code>ing it from the <code>for(count)</code> call.</p>

<h2>
<a name="creating-modifiers" class="anchor" href="#creating-modifiers"><span class="octicon octicon-link"></span></a>Creating Modifiers</h2>

<p>With fluent APIs, it can be useful to declare modifiers that alter the behavior of all methods that descend
from them in the object graph. For this, chainlang exposes the <code>chainlang.proxy</code> method. This allows you to
create a copy of an object with all of its methods proxied. This is the same technique used by
chainlang to create an object with chainable methods in <code>chainlang.create</code>.</p>

<pre><code>var is = {};

// `is.even(...)` determines whether a value is even
is.even = function(){
    return (this._subject % 2 === 0);
};

// `isNot` has all the same methods of `is`, but negates their returns
var isNot = chainlang.proxy(is, function(fn){
    return function(){
        return !fn.apply(this, arguments);  
    };
});

is.not = isNot;

is = chainlang.create(is);

// Logs: true
console.log(
    is(68).even()
);

// Logs: false
console.log(
    is(68).not.even()
);
</code></pre>

<h1>
<a name="more-information" class="anchor" href="#more-information"><span class="octicon octicon-link"></span></a>More Information</h1>

<ul>
<li><a href="http://jbreeden.github.io/chainlang/spec/spec.html">The chainlang spec</a></li>
<li><a href="http://jbreeden.github.io/chainlang/fromjs/from.html">Example: Creating a full-feature fromjs library</a></li>
<li><a href="http://jbreeden.github.io/chainlang/source/chainlang.html">Annotated source of chainlang.js</a></li>
</ul>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Chainlang maintained by <a href="https://github.com/jbreeden">jbreeden</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-42220461-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
