<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Chainlang : Utility for creating chainable methods and fluent interfaces" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Chainlang</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/jbreeden/chainlang">View on GitHub</a>

          <h1 id="project_title">Chainlang</h1>
          <h2 id="project_tagline">Utility for creating chainable methods and fluent interfaces</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/jbreeden/chainlang/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/jbreeden/chainlang/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="-under-construction-" class="anchor" href="#-under-construction-"><span class="octicon octicon-link"></span></a>!!! UNDER CONSTRUCTION !!!</h1>

<p>Nevertheless, feel free to look around.</p>

<h1>
<a name="chainlang" class="anchor" href="#chainlang"><span class="octicon octicon-link"></span></a>Chainlang</h1>

<p>Chainlang is a utility for easily creating chainable methods and complex fluent APIs (or fluent interfaces) in JavaScript.</p>

<p>With chainlang, you define the hierarchical structure of your fluent API as an object with methods. These methods may exist on the top level object, or be arbitrarily nested within child objects. After you've defined this structure representing your new "chain language" (we'll call it your "language spec") you pass it to <code>chainlang.create</code> which takes care of details like making methods chainable, or allowing links in a chained expression to share data.</p>

<p>So, for example, with a language defined like this:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">fromSpec</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">where</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cond</span><span class="p">){</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_subject</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_subject</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">cond</span><span class="p">);</span>
    <span class="p">},</span>
    <span class="nx">take</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">all</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">_return</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_subject</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">from</span> <span class="o">=</span> <span class="nx">chainlang</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">fromSpec</span><span class="p">);</span>
</pre></div>

<p>we would then be able to:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>

<span class="kd">var</span> <span class="nx">evens</span> <span class="o">=</span> 
    <span class="nx">from</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">where</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">num</span><span class="p">){</span>
        <span class="k">return</span> <span class="nx">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> 
    <span class="p">}).</span><span class="nx">take</span><span class="p">.</span><span class="nx">all</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">evens</span><span class="p">);</span> <span class="c1">// Logs: [ 2, 4, 6 ]</span>
</pre></div>

<p>Granted, this isn't the most feature-filled API ever created (we'll be extending it later), but it was incredibly simple to define. There are no closures to capture the argument to the <code>from(...)</code> function, it is simply accessible by any method in our language spec, at any level in the hierarchy, as <code>this._subject</code>.</p>

<p>Also, no care was taken to return <code>this</code> from the methods of <code>fromSpec</code>. In fact, <code>fromSpec.where</code> returns a boolean, but we're still able to chain a call such as <code>from(numbers).where(cond).take.all()</code>. That's because <code>chainlang.create</code> creates a copy of its argument (the language spec) where all methods are proxied. The proxied methods all have their <code>this</code> context bound to a chain object, and they all return the same chain object.</p>

<p>So, what happens if you want to return a value? Just as in <code>fromSpec.take.all</code> above, you call <code>this._return</code> with some argument. This sets a flag on the chain object itself that tells the proxied methods to break the chain and return whatever value you've provided. (Note: this call does not actually cause your method to return, it just sets up a return value. If you call <code>this._return</code> again before your method finishes, you will overwrite the previous return value.)</p>

<h1>
<a name="features" class="anchor" href="#features"><span class="octicon octicon-link"></span></a>Features</h1>

<p>UA-42220461-1
The feature set is still in flux and so isn't fully documented yet.</p>

<p>For now, have a look at a snapshot of the <a href="http://jbreeden.github.io/chainlang/source.html">annotated source</a>
and the <a href="http://jbreeden.github.io/chainlang/spec.html">spec</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Chainlang maintained by <a href="https://github.com/jbreeden">jbreeden</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-42220461-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
