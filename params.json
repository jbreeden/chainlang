{"name":"Chainlang","tagline":"Utility for easily creating chainable methods and complex fluent APIs in JavaScript","body":"<script>\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-42220461-1', 'jbreeden.github.io');\r\n  ga('send', 'pageview');\r\n\r\n</script>\r\n\r\n# Chainlang\r\n\r\nChainlang is a utility for easily creating chainable methods and complex fluent APIs (or fluent interfaces) in JavaScript.\r\n\r\n# Introduction\r\n\r\nWith chainlang, you define the hierarchical structure of your fluent API as a plain-old JavaScript object. After you've defined this structure (we'll call it your \"language specification\") you pass it to `chainlang.create` which takes care of details like making methods chainable or allowing links in a chained expression to share data, among other things.\r\n\r\nSo, for example, with a language defined like this:\r\n\r\n```javascript\r\nvar fromSpec = {\r\n    where: function(cond){\r\n        this._subject = this._subject.filter(cond);\r\n    },\r\n    take: {\r\n        all: function(){\r\n            this._breaksChain();\r\n            return this._subject\u0001;\r\n        }\r\n    }\r\n};\r\n\r\nvar from = chainlang.create(fromSpec);\r\n```\r\n\r\nwe would be able to:\r\n\r\n```javascript\r\nvar numbers = [1, 2, 3, 4, 5, 6];\r\n\r\nvar evens = \r\n    from(numbers)\r\n    .where(function(num){\r\n        return num % 2 == 0; \r\n    }).take.all();\r\n\r\nconsole.log(evens); // Logs: [ 2, 4, 6 ]\r\n```\r\n\r\nGranted, this isn't the most feature-filled API ever created ([yet](http://jbreeden.github.io/chainlang/fromjs/from.html)), but it was incredibly simple to define. There are no closures or other tricks to capture the argument to the `from(...)` function, it is simply accessible by any method in our language spec, at any level in the hierarchy, as `this._subject`.\r\n\r\nAlso note that no care was taken to return `this` from the methods of `fromSpec` as is typical with chainable methods. In fact, `fromSpec.where` doesn't return anything, but we're still able to chain together an expression such as `from(numbers).where(cond).take.all()`. That's because `chainlang.create` creates a copy of its argument (the language spec) where all methods are proxied. The proxied methods all have their `this` context permanently bound to a chain object, and they all return the chain object implicitly.\r\n\r\nSo, what happens if you want to return a value? Just as in `fromSpec.take.all` above, you call `this._breaksChain()`. This sets a flag on the chain object itself that tells the proxied methods to return their own return value instead of implicitly returning the chain object.\r\n\r\nThat's the basic idea.\r\n\r\n# Features\r\n\r\nChainlang provides a small but powerful set of features to control the semantics of your generated API.\r\nSome of these features, like the `_breaksChain` method discussed in the introduction, are fields or methods\r\naccessible via `this` within the methods of your language specification object. Others, like `_wrapper`, are\r\nspecial nodes that can be placed within your specification. (For an interesting use of `_wrapper` nodes, see\r\nthe section on \"Join Wrappers\" in the [full fromjs example](http://jbreeden.github.io/chainlang/fromjs/from.html))\r\n\r\nTo see all the available features, check out the [chainlang spec](http://jbreeden.github.io/chainlang/spec/spec.html).\r\n\r\n# More Resources\r\n\r\n* [Example: Creating a full-feature fromjs library](http://jbreeden.github.io/chainlang/fromjs/from.html)\r\n* [Annotated source of chainlang.js](http://jbreeden.github.io/chainlang/source/chainlang.html)","google":"UA-42220461-1","note":"Don't delete this file! It's used internally to help with page regeneration."}