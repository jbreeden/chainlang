{"name":"Chainlang","tagline":"Utility for creating chainable methods and fluent interfaces","body":"# !!! UNDER CONSTRUCTION !!!\r\n\r\nPlease, feel free to look around - so long as you don't judge me.\r\n\r\n# chainlang\r\n\r\nChainlang is a utility for creating chainable methods and fluent interfaces.\r\n\r\n# Features\r\n\r\nThey're sweet, I assure you... but I can't tell you about them yet.\r\n\r\nFor now, have a look at the [annotated source](http://jbreeden.github.io/chainlang/source.html)\r\nand the [spec](http://jbreeden.github.io/chainlang/spec.html)\r\n\r\n# Example\r\n\r\nIn this example, we'll implement a library dubbed `from` atop chainlang. The `from` library will provide basic\r\ncollection querying/projecting facilities in a yoda-sql style api. `from` is defined as follows:\r\n\r\n```javascript\r\nvar chainlang = require('../chainlang.js');\r\n\r\nvar fromSpec = {};\r\n\r\nfromSpec.where = function(cond){\r\n    var result = this._subject.filter(cond);\r\n    this._subject = result;\r\n}\r\n\r\nfromSpec.select = function(projector){\r\n    // If called with keys, create projector\r\n    if(typeof projector !== \"function\"){\r\n        projector = makeProjectorForKeys.apply(null, arguments);\r\n    }\r\n\r\n    var result = [];\r\n    this._subject.forEach(function(el){\r\n        result.push(projector(el))\r\n    });\r\n    this._subject = result;\r\n}\r\n\r\nfromSpec.first = function(){\r\n    if(!(this._subject.length >= 1)){\r\n        return;\r\n    }\r\n    this._return(this._subject[0]);\r\n}\r\n\r\nfromSpec.last = function(){\r\n    if(!(this._subject.length >= 1)){\r\n        return;\r\n    }\r\n    this._return(this._subject[this._subject.length]);\r\n}\r\n\r\nfromSpec.all = function(){\r\n    this._return(this._subject);\r\n}\r\n\r\nfunction makeProjectorForKeys(){\r\n    var args = arguments;\r\n    \r\n    return function keysProjector(el){\r\n        debugger;\r\n        var projection = {};\r\n        for(var i = 0; i < args.length; ++i){\r\n            projection[args[i]] = el[args[i]];\r\n        }\r\n        return projection;\r\n    }\r\n}\r\n\r\nmodule.exports = chainlang.create(fromSpec);\r\n```\r\n\r\nAs you can see from the above definition, `from` provides filtering via `where` and projection via `select`. `select` \r\naccepts either a list of keys to project, or a mapping function that takes an element and returns the desired\r\nprojection. As with all chainable methods, these methods return the object they were called on so that more method\r\ncalls may be chained. So, to return the results of the filtering/projection, the methods `first`, `last`, and `all`\r\nare provided. Each of these methods utilizes the semi-private `_return` method of the chain object, which is provided\r\nto all chain languages created with `chainlang.create`. `_return` allows you to break the chain and return a value\r\nof your choosing.\r\n\r\nOk, so `from` is small, but functional. Let's see it in action. Suppose we have a list of employees, the declaration of\r\nwhich looks like this:\r\n\r\n```javascript\r\nvar from = require('./from');\r\n\r\nvar employees = [\r\n    {\r\n        id: 1,\r\n        name: \"Thomas\",\r\n        role: \"developer\"\r\n    },\r\n    {\r\n        id: 2,\r\n        name: \"David\",\r\n        role: \"manager\",\r\n        minions: [1, 3]\r\n    },\r\n    {\r\n        id: 3,\r\n        name: \"Mark\",\r\n        role: \"developer\"\r\n    },\r\n    {\r\n        id: 4,\r\n        name: \"Brian\",\r\n        role: \"developer\"\r\n    }\r\n];\r\n```\r\n\r\nThis list includes three developers and one manager, David. David has two employees, and their employee IDs are listed\r\nin David's `minions` array. If we want to find all of David's minions, we could start by getting their IDs. Using\r\n`from`, we can:\r\n\r\n```javascript\r\nvar davidsMinionsIds = \r\n    from(employees)\r\n    .where(function(employee){ \r\n        return employee.name == \"David\";\r\n    })\r\n    .select(function(employee){\r\n        return employee.minions;\r\n    })\r\n    .first();\r\n```\r\n\r\nThanks to `from`'s fluent api, this reads rather nicely as \"from employees, where employee name is David, select\r\nemployee's minions.\" Since select returns an array that we know will only have one element, we use `first` to break\r\nthe chain and return the minion id array directly.\r\n\r\nNow that we have David's minions' IDs, we can get their employee objects. To do this, we'll use another `from` query:\r\n\r\n```javascript\r\nvar davidsMinions = \r\n    from(employees)\r\n    .where(function(emp){\r\n        return davidsMinionsIds.indexOf(emp.id) != -1;\r\n    })\r\n    .all();\r\n```\r\n\r\n(To be continued... and improved...)\r\n","google":"UA-42220461-1","note":"Don't delete this file! It's used internally to help with page regeneration."}