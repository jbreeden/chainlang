{"name":"Chainlang","tagline":"Utility for creating chainable methods and fluent interfaces","body":"<script>\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-42220461-1', 'jbreeden.github.io');\r\n  ga('send', 'pageview');\r\n\r\n</script>\r\n\r\n# !!! UNDER CONSTRUCTION !!!\r\n\r\nNevertheless, feel free to look around.\r\n\r\n# Chainlang\r\n\r\nChainlang is a utility for easily creating chainable methods and complex fluent APIs (or fluent interfaces) in JavaScript.\r\n\r\nWith chainlang, you define the hierarchical structure of your fluent API as an object with methods. These methods may exist on the top level object, or be arbitrarily nested within child objects. After you've defined this structure representing your new \"chain language\" (we'll call it your \"language spec\") you pass it to `chainlang.create` which takes care of details like making methods chainable, or allowing links in a chained expression to share data.\r\n\r\nSo, for example, with a language defined like this:\r\n\r\n```javascript\r\nvar fromSpec = {\r\n    where: function(cond){\r\n        this._subject = this._subject.filter(cond);\r\n    },\r\n    take: {\r\n        all: function(){\r\n            this._return(this._subject);\r\n        }\r\n    }\r\n};\r\n\r\nvar from = chainlang.create(fromSpec);\r\n```\r\n\r\nwe would then be able to:\r\n\r\n```javascript\r\nvar numbers = [1, 2, 3, 4, 5, 6];\r\n\r\nvar evens = \r\n    from(numbers)\r\n    .where(function(num){\r\n        return num % 2 == 0; \r\n    }).take.all();\r\n\r\nconsole.log(evens); // Logs: [ 2, 4, 6 ]\r\n```\r\n\r\nGranted, this isn't the most feature-filled API ever created ([yet](http://jbreeden.github.io/chainlang/fromjs/from.html)), but it was incredibly simple to define. There are no closures to capture the argument to the `from(...)` function, it is simply accessible by any method in our language spec, at any level in the hierarchy, as `this._subject`.\r\n\r\nAlso, no care was taken to return `this` from the methods of `fromSpec`. In fact, `fromSpec.where` returns a boolean, but we're still able to chain a call such as `from(numbers).where(cond).take.all()`. That's because `chainlang.create` creates a copy of its argument (the language spec) where all methods are proxied. The proxied methods all have their `this` context bound to a chain object, and they all return the same chain object.\r\n\r\nSo, what happens if you want to return a value? Just as in `fromSpec.take.all` above, you call `this._return` with some argument. This sets a flag on the chain object itself that tells the proxied methods to break the chain and return whatever value you've provided. (Note: this call does not actually cause your method to return, it just sets up a return value. If you call `this._return` again before your method finishes, you will overwrite the previous return value.)\r\n\r\n# More Information\r\n* [Walkthrough: Creating a full-feature fromjs library](http://jbreeden.github.io/chainlang/fromjs/from.html)\r\n* [annotated source](http://jbreeden.github.io/chainlang/source/chainlang.html)\r\n* [spec](http://jbreeden.github.io/chainlang/spec/spec.html)","google":"UA-42220461-1","note":"Don't delete this file! It's used internally to help with page regeneration."}