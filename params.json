{"name":"Chainlang","tagline":"Utility for easily creating chainable methods and complex fluent APIs in JavaScript","body":"Chainlang\r\n=========\r\n\r\nChainlang is a utility for easily creating chainable methods and complex fluent APIs (or fluent interfaces) in JavaScript.\r\n\r\nMotivation\r\n==========\r\n\r\nFuent APIs make code easier to read and understand. Replacing a large options object parameter with a convenient\r\nfluent API can greatly simplify the use of many library functions. In an interactive environment like the\r\nnodejs repl, or the Firebug console, programmers can take advantage of auto-completion and exploratory programming\r\nto uncover the features of your fluent API without having to resort to the documentation.\r\n\r\nUsage\r\n=====\r\n\r\nCreating A Chainable API\r\n------------------------\r\n\r\nJust pass any JavaScript object to `chainlang.create` to create a chainable api:\r\n\r\n```\r\nvar adder = {\r\n    add: function(val){ \r\n        this._subject += val; \r\n    },\r\n    calc: function() { \r\n        return this._subject; \r\n    }\r\n}\r\n\r\nvar to = chainlang.create(adder);\r\n\r\n// Logs: 10\r\nconsole.log(\r\n    to(1).add(2).add(3).add(4).calc()\r\n);\r\n```\r\n\r\n`chainlang.create` will return a function that starts your chain expression. The optional parameter\r\nto this function will be saved in `this._subject` and accessible by all of your methods. If no value\r\nis returned by a method in the chain, the chain object itself is implicitly returned so you may\r\ncontinue to chain other methods.\r\n\r\nUsing `chainlang.append`\r\n------------------------\r\n\r\n`chainlang.append` is a simple function to help you build your language spec before passing it to\r\n`chainlang.create`. With `chainlang.append`, you can declare leaf nodes of an object graph and\r\nhave the parent nodes filled in for you.\r\n\r\n```\r\nvar spec = {};\r\nchainlang.append(spec, 'some.nested.method', function(){});\r\n\r\n// Logs: { some: { nested: { method: [Function] } } }\r\nconsole.log(spec);\r\n```\r\n\r\nIf you bind `chainlang.append` to some object, the first parameter may be omitted\r\n\r\n```\r\nvar spec = {};\r\nvar define = chainlang.append.bind(spec);\r\n\r\ndefine('another.nested.method', function(){});\r\n\r\n// Logs: { another: { nested: { method: [Function] } } }\r\nconsole.log(spec);\r\n```\r\n\r\nSharing Data Between Links\r\n--------------------------\r\n\r\nAlong with `this._subject`, all method calls have access to `this._data`. `this._data` is initially\r\nempty, and is simply provided as a convenient place to store information between links in a chained\r\nexpression.\r\n\r\n```\r\nvar spec = {};\r\nvar define = chainlang.append.bind(spec);\r\n\r\ndefine('setData', function(val){ \r\n    this._data.field = val; \r\n});\r\ndefine('logData', function(){ \r\n    console.log(this._data.field); \r\n});\r\n\r\nvar chain = chainlang.create(spec);\r\n\r\n// Logs: 999\r\nchain().setData(999).logData();\r\n```\r\n\r\nKeeping Your Privates Hidden\r\n----------------------------\r\n\r\nSometimes it's desirable to hide some methods of your chainable api until it makes sense to use them.\r\n`chainlang` provides no built-in support for this, but it is recommended that you simply hide these nodes\r\nbehind a field with a name like '_private'. That way, programmers using your api will not be tempted to use\r\nthese methods in a context where it does not make sense to do so. Also, keeping them *all* behind\r\na field like this, instand of simply prefixing them all with an '_' will prevent the auto-completion\r\nresults from being cluttered with fields that are supposed to be private in the first place. For example:\r\n\r\n```\r\nvar delaySpec = {};\r\nvar define = chainlang.append.bind(delaySpec);\r\n\r\ndefine('for', function(count){\r\n    this._data.count = count;\r\n    \r\n    // exposing our private 'units' object now that we have a count\r\n    return this._private.units;\r\n});\r\n\r\ndefine('_private.units.seconds.then', function(callback){\r\n    setTimeout(callback, this._data.count * 1000);\r\n});\r\n\r\ndefine('_private.units.minutes.then', function(callback){\r\n    setTimeout(callback, this._data.count * 1000 * 60)\r\n});\r\n\r\nvar delay = chainlang.create(delaySpec);\r\n\r\n// After 5 seconds, logs: '5 seconds elapsed'\r\ndelay().for(5).seconds.then(function(){\r\n    console.log('5 seconds elapsed');\r\n});\r\n\r\n// After 5 minutes, logs: '5 minutes elapsed'\r\ndelay().for(5).minutes.then(function(){\r\n    console.log('5 minutes elapsed');\r\n});\r\n```\r\n\r\nIn the previous example, it would not make sense to have an expression such as `delay().minutes.then(...)`.\r\nThe count needs to be declared before the units, so the units object is kept in private storage and exposed\r\nby `return`ing it from the `for(count)` call.\r\n\r\nMore Information\r\n================\r\n\r\n* [The chainlang spec](http://jbreeden.github.io/chainlang/spec/spec.html)\r\n* [Example: Creating a full-feature fromjs library](http://jbreeden.github.io/chainlang/fromjs/from.html)\r\n* [Annotated source of chainlang.js](http://jbreeden.github.io/chainlang/source/chainlang.html)","google":"UA-42220461-1","note":"Don't delete this file! It's used internally to help with page regeneration."}